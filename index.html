<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>接球计数器 Pro</title>
    <style>
        :root { --primary: #007aff; --success: #34c759; --danger: #ff3b30; }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        .header { margin-top: 60px; text-align: center; }
        #counter { font-size: 160px; font-weight: 800; font-variant-numeric: tabular-nums; margin: 20px 0; color: var(--success); text-shadow: 0 0 30px rgba(52, 199, 89, 0.3); }
        .status-badge { padding: 6px 15px; border-radius: 20px; font-size: 14px; background: #222; color: #888; transition: all 0.3s; }
        .active { background: rgba(52, 199, 89, 0.2); color: var(--success); }
        .controls { position: absolute; bottom: 80px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 20px; }
        button { width: 200px; height: 60px; border-radius: 30px; border: none; font-size: 20px; font-weight: 600; cursor: pointer; transition: transform 0.1s; }
        #startBtn { background: var(--primary); color: white; }
        #resetBtn { background: transparent; color: #666; font-size: 16px; }
        #log { font-size: 13px; color: #444; width: 80%; text-align: center; height: 40px; }
        .visualizer { position: absolute; top: 0; width: 100%; height: 100px; opacity: 0.3; pointer-events: none; }
    </style>
</head>
<body>

    <canvas id="visualizer" class="visualizer"></canvas>

    <div class="header">
        <div id="status" class="status-badge">等待授权麦克风</div>
        <div id="counter">0</div>
    </div>

    <div class="controls">
        <div id="log">请在安静环境下开始测试</div>
        <button id="startBtn">点击开始监测</button>
        <button id="resetBtn">归零</button>
    </div>

    <script>
        // --- 核心算法参数 ---
        const CONFIG = {
            threshold: 0.35,      // 灵敏度：数值越小越灵敏 (0.1 ~ 0.9)
            dropWindow: 650,      // 掉球判定窗：在此时间内有二次撞击视为掉球 (ms)
            coolDown: 200,        // 连击过滤：防止单次声音被重复计算 (ms)
            fftSize: 512
        };

        let count = 0;
        let isRunning = false;
        let audioCtx, analyser, dataArray;
        let lastEventTime = 0;
        let isWaitingForDrop = false;
        let wakeLock = null;

        const startBtn = document.getElementById('startBtn');
        const counterEl = document.getElementById('counter');
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');

        // 1. 初始化音频和屏幕常亮
        startBtn.onclick = async () => {
            if (isRunning) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = CONFIG.fftSize;
                source.connect(analyser);
                dataArray = new Float32Array(analyser.fftSize);

                // 激活屏幕常亮
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }

                isRunning = true;
                startBtn.style.display = 'none';
                statusEl.innerText = "监测中 - 屏幕常亮已开启";
                statusEl.classList.add('active');
                
                requestAnimationFrame(update);
            } catch (err) {
                alert("无法访问麦克风或您的浏览器不支持此功能");
                logEl.innerText = err.message;
            }
        };

        // 2. 实时监测逻辑
        function update() {
            analyser.getFloatTimeDomainData(dataArray);
            
            let maxAmp = 0;
            for (let i = 0; i < dataArray.length; i++) {
                let val = Math.abs(dataArray[i]);
                if (val > maxAmp) maxAmp = val;
            }

            const now = Date.now();

            // 核心判定算法
            if (maxAmp > CONFIG.threshold) {
                // 如果当前距离上一次声音非常近（比如声音的余响），直接忽略
                if (now - lastEventTime > 50) { 
                    handleSoundImpact(now);
                }
            }

            // 绘制简单的波形图（视觉反馈）
            drawVisualizer();
            requestAnimationFrame(update);
        }

        function handleSoundImpact(now) {
            if (!isWaitingForDrop) {
                // 可能是接球，先加分，进入观察期
                count++;
                isWaitingForDrop = true;
                lastEventTime = now;
                updateDisplay();
                logEl.innerText = "检测到撞击...";
                
                // 观察期结束后，如果没有后续撞击，则保留分数
                setTimeout(() => {
                    if (isWaitingForDrop && Date.now() - lastEventTime >= CONFIG.dropWindow) {
                        isWaitingForDrop = false;
                        logEl.innerText = "确认接球！";
                        logEl.style.color = "#34c759";
                    }
                }, CONFIG.dropWindow);

            } else {
                // 在观察期内又听到了声音 -> 判定为掉球（连续啪啪声）
                if (now - lastEventTime < CONFIG.dropWindow) {
                    count = Math.max(0, count - 1);
                    isWaitingForDrop = false; // 立即关闭观察期
                    updateDisplay();
                    logEl.innerText = "掉球检测：计数扣除";
                    logEl.style.color = "#ff3b30";
                    lastEventTime = now; // 更新时间，防止掉球的最后一下又触发接球
                }
            }
        }

        function updateDisplay() {
            counterEl.innerText = count;
            // 简单的动画效果
            counterEl.style.transform = "scale(1.1)";
            setTimeout(() => counterEl.style.transform = "scale(1)", 100);
        }

        document.getElementById('resetBtn').onclick = () => {
            count = 0;
            updateDisplay();
            logEl.innerText = "已清零";
        };

        // 3. 可视化背景（让用户知道程序没死）
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        function drawVisualizer() {
            const width = canvas.width = window.innerWidth;
            const height = canvas.height = 100;
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.moveTo(0, height/2);
            for(let i=0; i<dataArray.length; i++) {
                const x = (i / dataArray.length) * width;
                const y = (dataArray[i] * height) + height/2;
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = '#007aff';
            ctx.stroke();
        }
    </script>
</body>
</html>