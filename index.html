<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>接球计数器 Pro</title>
    <style>
        :root { --primary: #007aff; --success: #34c759; --danger: #ff3b30; }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        .header { margin-top: 50px; text-align: center; }
        #counter { font-size: 140px; font-weight: 800; margin: 10px 0; color: var(--success); }
        
        .panel { background: #1c1c1e; width: 85%; padding: 20px; border-radius: 20px; box-sizing: border-box; }
        .setting-item { margin-bottom: 20px; }
        .setting-label { display: flex; justify-content: space-between; margin-bottom: 10px; color: #888; font-size: 14px; }
        
        input[type=range] { width: 100%; height: 6px; background: #333; border-radius: 5px; appearance: none; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 24px; height: 24px; background: white; border-radius: 50%; border: 1px solid #ddd; }

        .status-badge { padding: 6px 12px; border-radius: 20px; font-size: 12px; background: #333; color: #aaa; margin-bottom: 15px; }
        .active { background: rgba(52, 199, 89, 0.2); color: var(--success); }

        .controls { margin-top: auto; margin-bottom: 50px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        button { width: 85%; height: 55px; border-radius: 15px; border: none; font-size: 18px; font-weight: 600; cursor: pointer; }
        #startBtn { background: var(--primary); color: white; }
        .secondary-btns { display: flex; width: 85%; gap: 10px; }
        .secondary-btns button { font-size: 14px; height: 45px; background: #2c2c2e; color: #ccc; }
        
        #log { font-size: 12px; color: #555; height: 30px; text-align: center; }
        .visualizer { position: absolute; top: 0; width: 100%; height: 80px; opacity: 0.5; }
    </style>
</head>
<body>

    <canvas id="visualizer" class="visualizer"></canvas>

    <div class="header">
        <div id="status" class="status-badge">未就绪</div>
        <div id="counter">0</div>
    </div>

    <div class="panel">
        <div class="setting-item">
            <div class="setting-label">
                <span>触发灵敏度 (阈值)</span>
                <span id="threshVal">0.35</span>
            </div>
            <input type="range" id="threshSlider" min="0.05" max="0.8" step="0.01" value="0.35">
        </div>
        <div id="log">等待点击开始...</div>
    </div>

    <div class="controls">
        <button id="startBtn">开始监测</button>
        <div class="secondary-btns">
            <button onclick="resetCount()">计数归零</button>
            <button onclick="forceReload()">清除缓存刷新</button>
        </div>
    </div>

    <script>
        let count = 0;
        let isRunning = false;
        let audioCtx, analyser, dataArray, highPassFilter;
        let lastEventTime = 0;
        let isWaitingForDrop = false;
        let wakeLock = null;

        const CONFIG = { dropWindow: 650 };

        // 1. 灵敏度实时调节
        const threshSlider = document.getElementById('threshSlider');
        const threshVal = document.getElementById('threshVal');
        threshSlider.oninput = () => {
            threshVal.innerText = threshSlider.value;
        };

        // 2. 初始化
        document.getElementById('startBtn').onclick = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);

                // 滤波算法：切掉3000Hz以下的音乐和人声
                highPassFilter = audioCtx.createBiquadFilter();
                highPassFilter.type = "highpass";
                highPassFilter.frequency.value = 3000;

                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;

                source.connect(highPassFilter);
                highPassFilter.connect(analyser);
                dataArray = new Float32Array(analyser.fftSize);

                await requestWakeLock();
                
                isRunning = true;
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('status').innerText = "监测中 | 高频滤波已激活";
                document.getElementById('status').classList.add('active');
                
                requestAnimationFrame(update);
            } catch (err) {
                alert("请允许麦克风权限");
            }
        };

        // 3. 常亮逻辑优化：处理切换程序后的重连
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log("常亮激活");
                } catch (err) { console.log(err); }
            }
        }

        // 当用户切回 App 时，尝试重新申请常亮
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // 4. 核心检测算法
        function update() {
            if (!isRunning) return;
            analyser.getFloatTimeDomainData(dataArray);
            
            let maxAmp = 0;
            for (let i = 0; i < dataArray.length; i++) {
                let val = Math.abs(dataArray[i]);
                if (val > maxAmp) maxAmp = val;
            }

            const now = Date.now();
            const currentThreshold = parseFloat(threshSlider.value);

            if (maxAmp > currentThreshold && (now - lastEventTime > 50)) {
                handleImpact(now);
            }

            drawVisualizer();
            requestAnimationFrame(update);
        }

        function handleImpact(now) {
            const logEl = document.getElementById('log');
            if (!isWaitingForDrop) {
                count++;
                isWaitingForDrop = true;
                lastEventTime = now;
                updateUI();
                logEl.innerText = "收到撞击...";
                
                setTimeout(() => {
                    if (isWaitingForDrop && (Date.now() - lastEventTime >= CONFIG.dropWindow)) {
                        isWaitingForDrop = false;
                        logEl.innerText = "确认接到！";
                    }
                }, CONFIG.dropWindow);
            } else {
                if (now - lastEventTime < CONFIG.dropWindow) {
                    count = Math.max(0, count - 1);
                    isWaitingForDrop = false;
                    updateUI();
                    logEl.innerText = "检测到连响（掉球）";
                    lastEventTime = now;
                }
            }
        }

        function updateUI() {
            document.getElementById('counter').innerText = count;
        }

        function resetCount() {
            count = 0;
            updateUI();
            document.getElementById('log').innerText = "已重置";
        }

        function forceReload() {
            if(confirm("将清除缓存并重新加载，确定吗？")) {
                window.location.reload(true);
            }
        }

        // 5. 简单的可视化
        function drawVisualizer() {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const w = canvas.width = window.innerWidth;
            const h = canvas.height = 80;
            ctx.clearRect(0,0,w,h);
            ctx.beginPath();
            ctx.strokeStyle = '#007aff';
            for(let i=0; i<dataArray.length; i++) {
                ctx.lineTo((i/dataArray.length)*w, (dataArray[i]*h)+h/2);
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
